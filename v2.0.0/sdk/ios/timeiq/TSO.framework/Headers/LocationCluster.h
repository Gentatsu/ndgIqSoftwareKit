//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: //com/intel/wearable/platform/timeiq/places/modules/visitsmodule/algs/LocationCluster.java
//

#ifndef _LocationCluster_H_
#define _LocationCluster_H_

@class CLUSTER_STATE;
@class ClusterParameters;
#import "JBLogger.h"
#import "JBVector.h"
@class LocationCluster_CentroidPoint;
@class LocationCluster_NavPointEx;

#import "JB.h"
#include "NavPoint.h"

/**
 @brief A clustering algorithm - given a sequence of GPS locations, analyzes the sequence (taken into account data noises) and creates clusters that represent places where the user spends longer than a given duration of time.
 @author Chieh-Yih Wan (SSR, Intel Labs)
 */
@interface LocationCluster : NSObject {
 @public
  /**
   @brief A sliding window is used to maintain a list of points to track movement.
   This adds the notion of hysteresis to the clustering algorithm
   */
  Vector *slidingWindow_;
  /**
   @brief Number of points to include in the sliding window
   */
  int slidingWindowSize_;
  /**
   @brief Used to detect movement.
   If the distance of the point from the centroid is > than this, it indicates the user is moving Note: represented in Euclidean distance on earth lat/long coordinate system
   */
  double deltaDistanceThreshold_;
  /**
   @brief Used for hysteresis
   */
  int minNumPoints_;
  /**
   @brief Seconds that the user "pauses" at a location (threshold).
   If the user spends more than this threshold at a location, that is considered a pause. Set this value carefully.
   */
  double pauseTimeSecs_;
  /**
   @brief Minutes that the user dwells at a location (threshold).
   If the user spends more than this threshold at a location, that is considered a point of interest. Set this value carefully.  Too large a value may result in fewer clusters, too small a value may result in a large number of clusters, some of which may be insignificant.
   */
  double StagnancyTimeMins_;
  /**
   @brief Minimum speed in mph to consider as traveling
   */
  double minimumTravelSpeed_;
  /**
   @brief Size of the sliding window for speed calculation with hysteresis/smoothing
   */
  int speedHysteresisWindowSize_;
  boolean inCluster_;
  /**
   @brief The start time (in epoch seconds) of the cluster.
   */
  long64 clusterStartTime_;
  /**
   @brief Dynamic Dwell time compensation (in seconds) for the sliding window.
   Set to zero if sampling rate is fixed, i.e., legacy, compensation is done in the cluster agent's API.
   */
  long64 slidingWindowDynamicDelta_;
  /**
   @brief Track if location updates come at a random time or fixed interval
   */
  boolean isVariableSamplingRate_;
  /**
   @brief Centroid of the cluster
   */
  LocationCluster_CentroidPoint *centroid_;
  /**
   @brief Is a pause currently active?
   */
  boolean inPause_;
  /**
   @brief Represents the first location point
   */
  LocationCluster_NavPointEx *firstPoint_p_;
  /**
   @brief Unique cluster ID, increment for every new cluster
   */
  long64 UID_;
  /**
   @brief Maximum cluster radius (miles)
   */
  double maximumClusterRadius_;
  /**
   @brief Maximum in-cluster roaming radius (miles) defines the coverage of a specific semantic place within a cluster
   */
  double maximumInClusterRoamingRadius_;
  /**
   @brief Maximum Time Gap (minute) for correlated locations
   */
  double maximumCorrelationTimeGap_;
  /**
   @brief Minimum Cluster Radius in Feet, this is used to avoid forming cluster that is too small
   */
  double minimumClusterRadiusFeet_;
  /**
   @brief State of the current cluster
   */
  CLUSTER_STATE *state_;
  /**
   @brief Confidence value (0-1) of the current cluster state
   */
  double clusterStateConfValue_;
  ClusterParameters *params_;
}

/**
 @brief Reset cluster params to default
 */
- (void)initCluster OBJC_METHOD_FAMILY_NONE;

/**
 @brief Set to true for algorithm to work independent of the location sampling rate.
 @param isVariable Set to true if location sampling rate is not fixed
 */
- (void)setVariableSamplingRateWithBoolean:(boolean)isVariable;

- (void)setParams;

/**
 @brief Given a sequences of GPS locations, analyzes the sequence and creates clusters which are places where the user spends > a specified threshold of time
 */
- (instancetype)init;

/**
 @brief Constructor for LocationCluster that allows user to set the parameters for the class conveniently in one place
 @param NewParameters ClusterParameter object that define the params
 */
- (instancetype)initWithClusterParameters:(ClusterParameters *)NewParameters;

/**
 @brief Enable sparse tracking mode that clusters based on sparse location data as opposed to high frequency / continuous location updates
 @param enable True to enable this mode, false to disable
 */
- (void)SetSparseTrackingModeWithBoolean:(boolean)enable;

- (void)addToSlidingWindowWithNavPoint:(NavPoint *)newPoint;

/**
 @brief Conclude and reset the centroid
 */
- (void)endCluster;

- (NSString *)StateToStringWithCLUSTER_STATE:(CLUSTER_STATE *)state;

- (void)ForceEndCluster;

/**
 @brief Add a navigation point to the clustering algorithm for analysis.
 This method is the core of the clustering algorithm.
 @param newPoint New point to be added
 @return 
 */
- (boolean)AddPointWithNavPoint:(NavPoint *)newPoint;

- (double)GetClusterStateConfidence;

/**
 @brief Return a location object using the centroid coordinates and radius
 @return Location of the centroid
 */
- (NavPoint *)GetLocation;

/**
 @brief Get the duration of the current cluster in seconds since it's formed
 @return Time duration in seconds
 */
- (int)GetClusterDuration;

- (long64)GetDurationWithLong:(long64)dtStart
                    withLong:(long64)dtEnd;

/**
 @brief Calculate the average speed over the current and previous N-1 data points
 @param p Current point
 @param winSize Sliding window size
 @return Average speed in mph
 */
- (double)GetLastN_SpeedWithNavPoint:(NavPoint *)p
                              withInt:(int)winSize;

/**
 @brief Set the minimum dwell time to consider a STAY
 @param min Time in minutes
 */
- (void)SetClusterStagnancyTimeMinutesWithInt:(int)min;

/**
 @brief Set the minimum speed in mph to consider as TRAVEL
 @param speed_ Speed in mph
 */
- (void)SetTravelSpeedThresholdWithDouble:(double)speed_;

/**
 @brief Set the maximum p-2-p distance threshold to be included in a cluster
 @param delta_ Euclidean distance
 */
- (void)SetDeltaDistanceThresholdWithDouble:(double)delta_;

/**
 @brief Set the maximum cluster size in miles
 @param radius_ Radius in miles
 */
- (void)SetMaxClusterRadiusWithDouble:(double)radius_;

/**
 @brief Set the maximum in-cluster roaming radius(miles)
 @param radius_ Distance in miles
 */
- (void)SetMaxInClusterRoamingRadiusWithDouble:(double)radius_;

/**
 @brief Set the sliding window size for the travel hysteresis
 @param win_ Window size
 */
- (void)SetHysteresisWindowWithInt:(int)win_;

/**
 @brief Retrieve the unique ID of the current cluster
 @return Cluster ID
 */
- (long64)GetUID;

/**
 @brief Retrieve the start time of the cluster
 @return Epoch time in seconds
 */
- (long64)GetclusterStartTime;

/**
 @brief Retrieve the time the user dwells at a location (threshold).
 If the user spends more than this threshold at a location, that is considered a point of interest. Set this value carefully.  Too large a value may result in fewer clusters, too small a value may result in a large number of clusters, some of which may be insignificant.
 */
- (double)GetStagnancyTimeMins;

- (LocationCluster_CentroidPoint *)Getcentroid;

- (double)GetminimumTravelSpeed;

- (void)copyAllFieldsTo:(LocationCluster *)other;

@end

FOUNDATION_EXPORT BOOL LocationCluster_initialized;
J2OBJC_STATIC_INIT(LocationCluster)

//J2OBJC_FIELD_SETTER(LocationCluster, slidingWindow_, Vector *)
//J2OBJC_FIELD_SETTER(LocationCluster, centroid_, LocationCluster_CentroidPoint *)
//J2OBJC_FIELD_SETTER(LocationCluster, firstPoint_p_, LocationCluster_NavPointEx *)
//J2OBJC_FIELD_SETTER(LocationCluster, state_, CLUSTER_STATE *)
//J2OBJC_FIELD_SETTER(LocationCluster, params_, ClusterParameters *)

FOUNDATION_EXPORT Logger *LocationCluster_ClusterLogger_;
J2OBJC_STATIC_FIELD_GETTER(LocationCluster, ClusterLogger_, Logger *)
//J2OBJC_STATIC_FIELD_SETTER(LocationCluster, ClusterLogger_, Logger *)

typedef LocationCluster ComIntelWearablePlatformTimeiqPlacesModulesVisitsmoduleAlgsLocationCluster;

/**
 @brief Represents the centroid of a cluster
 */
@interface LocationCluster_CentroidPoint : NSObject {
 @public
  /**
   @brief Latitude of the centroid
   */
  double Latitude_;
  /**
   @brief Longitude of the centroid
   */
  double Longitude_;
  /**
   @brief Number of points in the cluster
   */
  int NumPoints_;
  /**
   @brief Mathematical sum of all latitudes in the cluster
   */
  double sumLat_;
  /**
   @brief Mathematical sum of all longitudes in the cluster
   */
  double sumLong_;
  /**
   @brief Cluster radius in miles - approximated by the maximum value between previous radiuses, the distance between the first and last point to the current centroid of the cluster.
   */
  double Radius_;
  /**
   @brief Distance between the current point and the centroid in miles
   */
  double currentRoamingDistance_;
  /**
   @brief First point of the cluster
   */
  NavPoint *FirstPoint_;
}

- (instancetype)initWithLocationCluster:(LocationCluster *)outer$;

- (void)Reset;

- (double)GetLatitude;

- (double)GetLongitude;

/**
 @brief Cluster radius - approximated by the maximum value between previous radiuses, the distance between the first and last point to the current centroid of the cluster.
 @return Radius in miles
 */
- (double)GetRadius;

/**
 @brief Add a point to the cluster and recalculate the centroid
 @param point Point to be added
 */
- (void)AddPointWithNavPoint:(NavPoint *)point;

/**
 @brief Calculate the euclidean distance of the point from the centroid
 @param point NavPoint (from GPS point)
 @return Euclidean distance
 */
- (double)GetDistanceWithNavPoint:(NavPoint *)point;

/**
 @brief Calculate the approximate distance in KM based on the Euclidean distance between the target point and the first point on earth coordinate system
 @param point Target point to measure from
 @return Approximated distance in KM
 */
- (double)GetApproxDistanceInKMWithNavPoint:(NavPoint *)point;

- (void)copyAllFieldsTo:(LocationCluster_CentroidPoint *)other;

@end

__attribute__((always_inline)) inline void LocationCluster_CentroidPoint_init() {}

//J2OBJC_FIELD_SETTER(LocationCluster_CentroidPoint, FirstPoint_, NavPoint *)

/**
 @brief Internal class used for clustering to track movement by tracking distance of the point from the centroid
 @author Chieh-Yih Wan (SSR, Intel Labs)
 */
@interface LocationCluster_NavPointEx : NavPoint {
 @public
  double DistanceTravelled_;
  double DistanceFromCentroid_;
  double DeltaDistanceFromCentroid_;
}

- (instancetype)initWithLocationCluster:(LocationCluster *)outer$;

- (instancetype)initWithLocationCluster:(LocationCluster *)outer$
                           withNavPoint:(NavPoint *)point;

- (instancetype)initWithLocationCluster:(LocationCluster *)outer$
                           withNavPoint:(NavPoint *)point
                               withLong:(long64)n_TimeStamp;

- (void)init__ OBJC_METHOD_FAMILY_NONE;

- (void)copyAllFieldsTo:(LocationCluster_NavPointEx *)other;

@end

__attribute__((always_inline)) inline void LocationCluster_NavPointEx_init() {}

#endif // _LocationCluster_H_
