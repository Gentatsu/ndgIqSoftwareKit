// Generated by Apple Swift version 2.1.1 (swiftlang-700.1.101.15 clang-700.1.81)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if defined(__has_include) && __has_include(<uchar.h>)
# include <uchar.h>
#elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
#endif

typedef struct _NSZone NSZone;

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted) 
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
#endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import Foundation;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSError;
@class WearableBodyActivity;


/// An object that can subscribe to WearableBodyActivity updates from a connected wearable.
SWIFT_PROTOCOL("_TtP6IQCore18BodyControllerType_")
@protocol BodyControllerType

/// Subscribes to body activity events from the associated wearable device.
///
/// \param receiver The closure that handles received activites.
- (void)subscribe:(void (^ __nonnull)(void))success failure:(void (^ __nonnull)(NSError * __nonnull))failure receiver:(void (^ __nonnull)(WearableBodyActivity * __nonnull))receiver;

/// Retrieves an activity report for a body activity.
///
/// \param success A completion handler closure that takes no arguments and returns no value. The handler is executed asynchronously.
///
/// \param failure A completion handler closure that takes an NSError object as an argument and returns no value. The handler is executed asynchronously.
///
/// \param receiver A type alias BodyActivityReceived. BodyActivityReceived is a type alias for a handler closure that takes a WearableBodyActivity as a named argument and returns no value.
- (void)getCurrentActivityReport:(void (^ __nonnull)(WearableBodyActivity * __nonnull))completion failure:(void (^ __nonnull)(NSError * __nonnull))failure;

/// Defines the desired level of granularity for events tracked in a body activity.
///
/// \param granularity An integer number specifying granularity in minutes, ranging from 5 to 60.
- (void)setOngoingActivityGranularity:(NSInteger)granularity;
@end

@protocol WearableControllerType;
@protocol FirmwareControllerType;


/// SDK entry-point for generating a FirmwareControllerType.
SWIFT_CLASS("_TtC6IQCore18FirmwareController")
@interface FirmwareController : NSObject
+ (id <FirmwareControllerType> __nullable)controllerForWearable:(id <WearableControllerType> __nonnull)controller;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// The FirmwareControllerType protocol is adopted by an object that installs firmware for a wearable device.
SWIFT_PROTOCOL("_TtP6IQCore22FirmwareControllerType_")
@protocol FirmwareControllerType

/// Installs firmware on the associated wearable device.
///
/// \param path The path to the binary containing the firmware to be installed.
///
/// \param started The closure that indicates that the firmware installation is initiated.
///
/// \param progress The closure that tracks the progress of the firmware installation.
///
/// \param completed The closure that indicates that the firmware installation is complete.
///
/// \param failed The closure that indicates that the firmware installation is unsuccessful.
- (void)installFirmware:(NSString * __nonnull)path started:(void (^ __nonnull)(void))started progress:(void (^ __nonnull)(NSInteger, NSInteger))progress completed:(void (^ __nonnull)(NSString * __nonnull))completed failed:(void (^ __nonnull)(NSError * __nonnull))failed;
@end

@class LogLevelChannel;


/// The Log class provides the public API for logging.
SWIFT_CLASS("_TtC6IQCore3Log")
@interface Log : NSObject

/// The error logging channel is used for error level messages.
+ (LogLevelChannel * __nullable)error;
+ (void)setError:(LogLevelChannel * __nullable)value;

/// The warning logging channel is used for warning level messages.
+ (LogLevelChannel * __nullable)warning;
+ (void)setWarning:(LogLevelChannel * __nullable)value;

/// The info logging channel is used for info level messages.
+ (LogLevelChannel * __nullable)info;
+ (void)setInfo:(LogLevelChannel * __nullable)value;

/// The debug logging channel is used for debug level messages.
+ (LogLevelChannel * __nullable)debug;
+ (void)setDebug:(LogLevelChannel * __nullable)value;

/// The verbose logging channel is used for verbose level messages.
+ (LogLevelChannel * __nullable)verbose;
+ (void)setVerbose:(LogLevelChannel * __nullable)value;

/// Disables logging to the console.
+ (void)disableConsoleLogging;

/// Disables logging to the file system.
+ (void)disableFileLogging;

/// Disables logging to the console and file system.
+ (void)disableAllLogging;

/// Used for getting the full file paths for log files.
///
/// \returns  An array file paths or nil if there are no log files.
+ (NSArray<NSString *> * __nullable)logFilePaths;

/// Used for getting the file names for log files.
///
/// \returns  An array of file names or nil if there are no log files.
+ (NSArray<NSString *> * __nullable)logFileNames;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// Logging is performed via a log level channel. The Log class maintains a log channel for each log level.
SWIFT_CLASS("_TtC6IQCore15LogLevelChannel")
@interface LogLevelChannel : NSObject
@end


@interface NSError (SWIFT_EXTENSION(IQCore))
@end

@class WearableNotification;


/// The NotificationControllerType protocol is adopted by an object sends WearableNotifications to a connected wearable.
SWIFT_PROTOCOL("_TtP6IQCore26NotificationControllerType_")
@protocol NotificationControllerType

/// Sends a wearable notification to the associated wearable device. Does not guarantee that the device successfully received and performed the notification.
///
/// \param notification The WearableNotification to send to the associated device.
///
/// \returns  a boolean representing if the notification was successfully validated, encoded, and broadcast.
- (BOOL)sendNotification:(WearableNotification * __nonnull)notification success:(void (^ __nonnull)(void))success failure:(void (^ __nonnull)(NSError * __nonnull))failure;
@end



/// A duration pattern specific to WearableNotifications
SWIFT_CLASS("_TtC6IQCore27NotificationDurationPattern")
@interface NotificationDurationPattern : NSObject

/// <ul><li>Number of seconds for which the vibration or LED is active.</li></ul>
@property (nonatomic) NSTimeInterval durationOn;

/// <ul><li>Number of seconds for which the vibration or LED is inactive.</li></ul>
@property (nonatomic) NSTimeInterval durationOff;
- (nonnull instancetype)initOn:(NSTimeInterval)on off:(NSTimeInterval)off OBJC_DESIGNATED_INITIALIZER;
@end


@interface NotificationDurationPattern (SWIFT_EXTENSION(IQCore))
@end


@interface NotificationDurationPattern (SWIFT_EXTENSION(IQCore))

/// Notification property values must meet certain criteria in order to be considered 'valid' and performable on a wearable. Test for validity before sending a notification to the device through a NotificationController.
@property (nonatomic, readonly) BOOL isValid;
@end

typedef SWIFT_ENUM(NSInteger, NotificationLEDPatternType) {
  NotificationLEDPatternTypeLEDBlink = 0,
  NotificationLEDPatternTypeLEDWave = 1,
};

@class UIColor;


/// LED pattern specific to WearableNotifications
SWIFT_CLASS("_TtC6IQCore22NotificationLedPattern")
@interface NotificationLedPattern : NSObject

/// <ul><li>Specifies which LED to use in the pattern.</li><li>Value validity depends on the connected device.</li></ul>
@property (nonatomic) uint32_t id;

/// <ul><li>LED patterns type.</li><li>Determines how the pattern is validated and rendered.</li></ul>
@property (nonatomic) enum NotificationLEDPatternType type;

/// <ul><li>A set of on and off durations.</li><li>For fixed patterns, only one should be provided.</li><li>For other pattern types, the set determines the number and pattern of a single repetition.</li></ul>
@property (nonatomic, copy) NSArray<NotificationDurationPattern *> * __nonnull durationPatterns;

/// <ul><li>Color or colors of the LEDs in the pattern.</li><li>At least one value should be provided.</li><li>When using multiple values for blink and wave patterns,</li><li>provide a color for every duration pattern specified.</li></ul>
@property (nonatomic, copy) NSArray<UIColor *> * __nonnull colors;

/// <ul><li>Number of repetitions for the entire pattern.</li></ul>
@property (nonatomic) uint32_t repetitionCount;

/// <ul><li>Brightness value for the LED, ranging from 0 (no light emitted) to 255 (most light emitted).</li></ul>
@property (nonatomic) uint32_t intensity;
- (nonnull instancetype)initWithType:(enum NotificationLEDPatternType)type OBJC_DESIGNATED_INITIALIZER;
@end


@interface NotificationLedPattern (SWIFT_EXTENSION(IQCore))
@end


@interface NotificationLedPattern (SWIFT_EXTENSION(IQCore))

/// Notification property values must meet certain criteria in order to be considered 'valid' and performable on a wearable. Test for validity before sending a notification to the device through a NotificationController.
@property (nonatomic, readonly) BOOL isValid;
@end

enum NotificationVibrationType : NSInteger;


/// A vibration pattern specific to WearableNotifications.
SWIFT_CLASS("_TtC6IQCore28NotificationVibrationPattern")
@interface NotificationVibrationPattern : NSObject

/// Type of vibration pattern.
@property (nonatomic, readonly) enum NotificationVibrationType type;

/// Amplitude value for the vibration pattern, ranging from 0 (no vibration) to 255 (full strength vibration).
@property (nonatomic) NSInteger amplitude;

/// Number of repetitions for this vibration pattern. All the duration pattern items are executed in order of appearance, and then repeated repetitionCount times.
@property (nonatomic) NSInteger repititionCount;

/// An array of Duration Patterns, which will be executed in the order added. (Current limit: 2)
@property (nonatomic, copy) NSArray<NotificationDurationPattern *> * __nonnull durationPatterns;

/// List of Effects, which will be executed in the same order as the one specified in the list.
@property (nonatomic, copy) NSArray<NSNumber *> * __nonnull effectsList;

/// Initializer for NotificationVibrationPatterns. Requires a vibration type.
- (nonnull instancetype)initWithType:(enum NotificationVibrationType)type OBJC_DESIGNATED_INITIALIZER;
@end


@interface NotificationVibrationPattern (SWIFT_EXTENSION(IQCore))
@end


@interface NotificationVibrationPattern (SWIFT_EXTENSION(IQCore))
@property (nonatomic, readonly, copy) NSString * __nonnull description;
@end


@interface NotificationVibrationPattern (SWIFT_EXTENSION(IQCore))

/// Notification property values must meet certain criteria in order to be considered 'valid' and performable on a wearable. Test for validity before sending a notification to the device through a NotificationController.
@property (nonatomic, readonly) BOOL isValid;
@end


/// Vibration Pattern supported types.
typedef SWIFT_ENUM(NSInteger, NotificationVibrationType) {
  NotificationVibrationTypeSquare = 0,
  NotificationVibrationTypeSpecialEffects = 1,
};



/// The RegistrationTokenType is a protocol adopted by an object that manages the subscription state of a wearable device.
SWIFT_PROTOCOL("_TtP6IQCore21RegistrationTokenType_")
@protocol RegistrationTokenType

/// Returns whether or not the subscription associated with the token is still valid.
@property (nonatomic, readonly) BOOL subscribed;

/// Unsubscribes from the associated subscription.
- (void)unsubscribe;
@end

@class WearableSystemEvent;


/// The NotificationControllerType protocol is adopted by an object that can subscribe to WearableSystemEvent updates from a connected wearable.
SWIFT_PROTOCOL("_TtP6IQCore26SystemEventsControllerType_")
@protocol SystemEventsControllerType

/// Subscribes to system events from the associated wearable device.
///
/// \param receiver The closure that handles received system events.
- (void)subscribe:(void (^ __nonnull)(void))success failure:(void (^ __nonnull)(NSError * __nonnull))failure receiver:(void (^ __nonnull)(WearableSystemEvent * __nonnull))receiver;
- (void)unsubscribe;
@end


@interface UIColor (SWIFT_EXTENSION(IQCore))
@end

@class WearableUserEvent;


/// The UserEventsControllerType protocol is adopted by an object that can subscribe to WearableUserEvent updates from a connected wearable.
SWIFT_PROTOCOL("_TtP6IQCore24UserEventsControllerType_")
@protocol UserEventsControllerType

/// Subscribes to user events from the associated wearable device.
///
/// \param receiver The closure that handles received user events.
- (void)subscribe:(void (^ __nonnull)(void))success failure:(void (^ __nonnull)(NSError * __nonnull))failure receiver:(void (^ __nonnull)(WearableUserEvent * __nonnull))receiver;
- (void)unsubscribe;
@end



/// Data model for an application user. Use the initializer's required identifier to associate local user data with their external storage system. Events relevant to a user will be tagged with the associated read-only UUID.
SWIFT_CLASS("_TtC6IQCore12UserIdentity")
@interface UserIdentity : NSObject

/// External user id, usually obtained by logging into a cloud service.
@property (nonatomic, readonly, copy) NSString * __nonnull identifier;

/// Unique identifier for the user. This is internally generated and managed.
@property (nonatomic, readonly, copy) NSString * __nonnull uuid;

/// User first name.
@property (nonatomic, copy) NSString * __nullable firstName;

/// User last name.
@property (nonatomic, copy) NSString * __nullable lastName;

/// User email address.
@property (nonatomic, copy) NSString * __nullable email;

/// User phone number.
@property (nonatomic, copy) NSString * __nullable phoneNumber;

/// Creates a UserIdentity by providing an external identifier. Intended for use with the LocalDataStore.
- (nonnull instancetype)initWithIdentifier:(NSString * __nonnull)identifier OBJC_DESIGNATED_INITIALIZER;
@end

enum WearableBodyActivityType : NSInteger;
enum WearableBodyActivityStatus : NSInteger;
@class NSDate;


/// A representaion of body/movement activity on a wearable device. Activities are tagged with user and wearable UUIDs to identify where the activities came from.
SWIFT_CLASS("_TtC6IQCore20WearableBodyActivity")
@interface WearableBodyActivity : NSObject

/// <ul><li>User identifier associated with the activity.</li></ul>
@property (nonatomic, copy) NSString * __nullable userUUID;

/// <ul><li>Wearable device identifier the activity is associated with.</li></ul>
@property (nonatomic, copy) NSString * __nullable wearableUUID;

/// <ul><li>Type of activity performed.</li></ul>
@property (nonatomic) enum WearableBodyActivityType type;

/// <ul><li>Status of the activity performed.</li></ul>
@property (nonatomic) enum WearableBodyActivityStatus status;

/// <ul><li>Value associated with the body activity. For walking or running, the key is "steps" and the value is an NSNumber.</li></ul>
@property (nonatomic, copy) NSDictionary * __nonnull value;

/// <ul><li>Time at which the activity began.</li></ul>
@property (nonatomic, strong) NSDate * __nonnull beganTime;

/// <ul><li>Time at which the activity ended.</li></ul>
@property (nonatomic, strong) NSDate * __nonnull endTime;
- (nonnull instancetype)initWithType:(enum WearableBodyActivityType)type status:(enum WearableBodyActivityStatus)status value:(NSDictionary * __nonnull)value began:(NSDate * __nonnull)began ended:(NSDate * __nonnull)ended OBJC_DESIGNATED_INITIALIZER;
@end


@interface WearableBodyActivity (SWIFT_EXTENSION(IQCore))
@end

typedef SWIFT_ENUM(NSInteger, WearableBodyActivityStatus) {
  WearableBodyActivityStatusStarted = 0,
  WearableBodyActivityStatusOngoing = 1,
  WearableBodyActivityStatusFinished = 2,
};

typedef SWIFT_ENUM(NSInteger, WearableBodyActivityType) {
  WearableBodyActivityTypeWalking = 0,
  WearableBodyActivityTypeRunning = 1,
  WearableBodyActivityTypeBiking = 2,
};

typedef SWIFT_ENUM(NSInteger, WearableCommunicationProtocol) {
  WearableCommunicationProtocolBLE = 0,
};


/// Connection states for wearable devices.
typedef SWIFT_ENUM(NSInteger, WearableConnectStatus) {
  WearableConnectStatusConnected = 0,
  WearableConnectStatusDisconnected = 1,
};

@class WearableToken;
@class WearableIdentity;


/// The WearableControllerType protocol is adopted by an object that provides the communication layer between the wearable device and the companion device.
SWIFT_PROTOCOL("_TtP6IQCore22WearableControllerType_")
@protocol WearableControllerType

/// Returns the token for the associated wearable device.
@property (nonatomic, readonly, strong) WearableToken * __nonnull token;
- (nonnull instancetype)initWithToken:(WearableToken * __nonnull)token;

/// Returns the WearableIdentity information for the associated wearable device. This property will only be populated after a successful connection is performed.
@property (nonatomic, readonly, strong) WearableIdentity * __nullable wearableIdentity;

/// Returns the connection status for the associated wearable device.
@property (nonatomic, readonly) enum WearableConnectStatus connectionStatus;

/// Adds a connection status observer. When the connection status changes the closure will be performed.
///
/// \param observer A closure that will be called whenever a connection status update occurs for the controller's associated wearable until the developer stops referencing the RegistrationToken or explicitly unsubscribes from it.
///
/// \returns  A RegistrationTokenType that is used to determine if the associated observer still desires to be called on connection change events.
- (id <RegistrationTokenType> __nonnull)addConnectionStatusObserver:(void (^ __nonnull)(enum WearableConnectStatus))observer;

/// Establishes a connection with the wearable. When the connection succeeds or fails the callback will be performed.
///
/// \param completion A closure to handle the result of a connection attempt.
- (void)connect:(void (^ __nonnull)(WearableToken * __nullable, NSError * __nullable))completion;

/// Disconnects or cancels a pending connection with the controllers associated wearable.
- (void)disconnect;

/// Requests the current battery status
///
/// \param completion A closure to handle the result of the battery level request.
- (void)getBatteryLevel:(void (^ __nonnull)(NSInteger, NSError * __nullable))completion;

/// Requests the current clock
///
/// \param completion A closure to handle the result of the get clock request.
- (void)getWallClock:(void (^ __nonnull)(int64_t, NSSet<NSString *> * __nonnull))completion;

/// Subscribes to receive battery status update events.
///
/// <code> - parameter update: A closure to handle each battery level update event received from the wearable.
/// 
/// </code>
- (void)subscribeToBatteryLevelUpdates:(void (^ __nonnull)(NSInteger, NSError * __nullable))update;

/// Unsubscribes to battery status update events.
- (void)unsubscribeToBatteryLevelUpdates;

/// Requests an update to the WearableIdentity object with information about the wearable device or null if this controller has not connected to the wearable device or fails to read the values.
///
/// \param completion A closure to handle the result of the wearable identity request.
- (void)updateWearableIdentity:(void (^ __nonnull)(WearableIdentity * __nullable, NSError * __nullable))completion;

/// Sends a factory reset command to the connected wearable device. Device will disconnect and restart after this method is called.
- (void)factoryReset;

/// Sets name of connected wearable device.
///
/// \param wearableName A string representing a desired name for connected wearable.
- (void)setWearableName:(NSString * __nonnull)wearableName;
@end



/// Data model for a wearable device. Events relevant to a device will be tagged with the associated read-only identifier.
SWIFT_CLASS("_TtC6IQCore16WearableIdentity")
@interface WearableIdentity : NSObject

/// Display name for device discovery.
@property (nonatomic, readonly, copy) NSString * __nonnull displayName;

/// Unique ID for the device. This is internally generated and managed.
@property (nonatomic, readonly, copy) NSString * __nonnull uuid;

/// Wearable device manufacturer.
@property (nonatomic, readonly, copy) NSString * __nonnull manufacturerName;

/// Wearable device model.
@property (nonatomic, readonly, copy) NSString * __nonnull modelNumber;

/// Wearable device serial number.
@property (nonatomic, readonly, copy) NSString * __nonnull serialNumber;

/// Wearable device firmware revision.
@property (nonatomic, readonly, copy) NSString * __nonnull firmwareRevision;

/// Wearable device software revision.
@property (nonatomic, readonly, copy) NSString * __nonnull softwareRevision;

/// Wearable device hardware revision.
@property (nonatomic, readonly, copy) NSString * __nonnull hardwareRevision;
@end



/// Representaion of a notification to be sent to a wearable device. Activities are tagged with user and wearable UUIDS to identify where the activities came from.
SWIFT_CLASS("_TtC6IQCore20WearableNotification")
@interface WearableNotification : NSObject

/// <ul><li>Vibration pattern for this notification.</li></ul>
@property (nonatomic, strong) NotificationVibrationPattern * __nullable vibrationPattern;

/// <ul><li>LED pattern for this notification.</li></ul>
@property (nonatomic, strong) NotificationLedPattern * __nullable ledPattern;

/// <ul><li>Delay in milliseconds before starting the pattern.</li></ul>
@property (nonatomic) NSTimeInterval startDelay;
- (nonnull instancetype)initWithVibrationPattern:(NotificationVibrationPattern * __nonnull)vibrationPattern delay:(NSTimeInterval)delay OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLedPattern:(NotificationLedPattern * __nonnull)ledPattern delay:(NSTimeInterval)delay OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLedPattern:(NotificationLedPattern * __nullable)ledPattern vibrationPattern:(NotificationVibrationPattern * __nullable)vibrationPattern delay:(NSTimeInterval)delay OBJC_DESIGNATED_INITIALIZER;
@end


@interface WearableNotification (SWIFT_EXTENSION(IQCore))
@end


@interface WearableNotification (SWIFT_EXTENSION(IQCore))

/// Notification property values must meet certain criteria in order to be considered 'valid' and performable on a wearable. Test for validity before sending the notification to the device through a NotificationController.
@property (nonatomic, readonly) BOOL isValid;
@end

@class NSNumber;


/// WearableScannerTokenResult encapsulates the data of an identified peripheral device and the signal strength between it and the companion device.
SWIFT_CLASS("_TtC6IQCore26WearableScannerTokenResult")
@interface WearableScannerTokenResult : NSObject

/// The token representing the peripheral device.
@property (nonatomic, readonly, strong) WearableToken * __nonnull token;

/// The RSSI number representing the signal strength to the associated peripheral device at the moment it was located.
@property (nonatomic, readonly, strong) NSNumber * __nonnull RSSI;
@end



/// WearableScannerTypes perform discovery of Intel wearable devices. Scanning is an asynchronous, non-blocking operation. Results of the scan are reported to the caller via supplied closures without exposing the details of the communication protocol.
///
/// This class is the entry point into the Intel SDK. Clients use this class to scan for Intel
/// wearables and obtain a WearableToken for any discovered wearable devices.
SWIFT_PROTOCOL("_TtP6IQCore19WearableScannerType_")
@protocol WearableScannerType

/// A boolean value that tells if the scanner is currently scanning.
@property (nonatomic, readonly) BOOL isScanning;

/// The communication protocol(s) on which this scanner searches for wearable devices.
- (enum WearableCommunicationProtocol)type;

/// Starts scanning for wearable devices
///
/// \param found A closure called after a wearable is found containing an SDK specific representation.
///
/// \param error A closure called when the scanner ends in an error.
///
/// \param finish A closure called when the scanner ends.
- (void)startScan:(void (^ __nonnull)(WearableScannerTokenResult * __nonnull))found error:(void (^ __nonnull)(NSError * __nonnull))error finish:(void (^ __nonnull)(void))finish;

/// Stops scanning for wearable devices
- (void)stopScan;
@end

enum WearableSystemEventBootType : NSInteger;

SWIFT_CLASS("_TtC6IQCore23WearableSystemBootEvent")
@interface WearableSystemBootEvent : NSObject
@property (nonatomic) enum WearableSystemEventBootType type;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6IQCore24WearableSystemCrashEvent")
@interface WearableSystemCrashEvent : NSObject
@property (nonatomic) NSInteger crashID;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class WearableSystemShutdownEvent;
@class WearableSystemLowBatteryEvent;

SWIFT_CLASS("_TtC6IQCore19WearableSystemEvent")
@interface WearableSystemEvent : NSObject

/// Boot associated with the system event.
@property (nonatomic, strong) WearableSystemBootEvent * __nullable bootEvent;

/// Shutdown associated with the system event.
@property (nonatomic, strong) WearableSystemShutdownEvent * __nullable shutdownEvent;

/// Crash associated with the system event.
@property (nonatomic, strong) WearableSystemCrashEvent * __nullable crashEvent;

/// Low battery warning associated with the system event.
@property (nonatomic, strong) WearableSystemLowBatteryEvent * __nullable lowBatteryEvent;

/// The time the event took place.
@property (nonatomic, strong) NSDate * __nonnull timeStamp;
- (nonnull instancetype)initWithBootEvent:(WearableSystemBootEvent * __nullable)bootEvent shutdownEvent:(WearableSystemShutdownEvent * __nullable)shutdownEvent crashEvent:(WearableSystemCrashEvent * __nullable)crashEvent lowBatteryEvent:(WearableSystemLowBatteryEvent * __nullable)lowBatteryEvent timeStamp:(NSDate * __nonnull)timeStamp OBJC_DESIGNATED_INITIALIZER;
@end


@interface WearableSystemEvent (SWIFT_EXTENSION(IQCore))
@end

typedef SWIFT_ENUM(NSInteger, WearableSystemEventBootType) {
  WearableSystemEventBootTypeMain = 0,
  WearableSystemEventBootTypeOta = 1,
  WearableSystemEventBootTypeFactoryReset = 2,
};

typedef SWIFT_ENUM(NSInteger, WearableSystemEventShutdownType) {
  WearableSystemEventShutdownTypeUser = 0,
  WearableSystemEventShutdownTypeCriticalBattery = 1,
};


SWIFT_CLASS("_TtC6IQCore29WearableSystemLowBatteryEvent")
@interface WearableSystemLowBatteryEvent : NSObject
@property (nonatomic) NSInteger batteryLevel;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6IQCore27WearableSystemShutdownEvent")
@interface WearableSystemShutdownEvent : NSObject
@property (nonatomic) enum WearableSystemEventShutdownType type;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// Identifies an Intel wearable device with a unique ID.
SWIFT_PROTOCOL("_TtP6IQCore17WearableTokenType_")
@protocol WearableTokenType

/// A unique identifier associated with the wearable token.
@property (nonatomic, readonly, copy) NSString * __nonnull id;

/// A human-readable name associated with the wearable token.
@property (nonatomic, readonly, copy) NSString * __nullable displayName;
@end



/// Uniquely identifies a wearable device with a unique ID.
SWIFT_CLASS("_TtC6IQCore13WearableToken")
@interface WearableToken : NSObject <WearableTokenType>

/// Unique identifier property.
@property (nonatomic, copy) NSString * __nonnull id;

/// This name will be visible during the wearable scanning process.
@property (nonatomic, copy) NSString * __nullable displayName;
@end


@interface WearableToken (SWIFT_EXTENSION(IQCore))
@property (nonatomic, readonly) NSInteger hashValue;
@end


@interface WearableToken (SWIFT_EXTENSION(IQCore))
@property (nonatomic, readonly, copy) NSString * __nonnull description;
@end


@class WearableUserEventGesture;
@class WearableUserEventButton;

SWIFT_CLASS("_TtC6IQCore17WearableUserEvent")
@interface WearableUserEvent : NSObject

/// <ul><li>Gesture associated with user event.</li></ul>
@property (nonatomic, strong) WearableUserEventGesture * __nullable gestureEvent;

/// Button press associated with user event.
@property (nonatomic, strong) WearableUserEventButton * __nullable buttonEvent;
- (nonnull instancetype)initWithGestureEvent:(WearableUserEventGesture * __nullable)gestureEvent buttonEvent:(WearableUserEventButton * __nullable)buttonEvent OBJC_DESIGNATED_INITIALIZER;
@end


@interface WearableUserEvent (SWIFT_EXTENSION(IQCore))
@end

enum WearableUserEventButtonType : NSInteger;

SWIFT_CLASS("_TtC6IQCore23WearableUserEventButton")
@interface WearableUserEventButton : NSObject
@property (nonatomic) NSInteger buttonID;
@property (nonatomic) enum WearableUserEventButtonType type;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, WearableUserEventButtonType) {
  WearableUserEventButtonTypeSinglePress = 0,
  WearableUserEventButtonTypeDoublePress = 1,
  WearableUserEventButtonTypeTriplePress = 2,
  WearableUserEventButtonTypeLongPress = 3,
  WearableUserEventButtonTypeUnknown = 4,
};

enum WearableUserEventGestureType : NSInteger;

SWIFT_CLASS("_TtC6IQCore24WearableUserEventGesture")
@interface WearableUserEventGesture : NSObject
@property (nonatomic) enum WearableUserEventGestureType type;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, WearableUserEventGestureType) {
  WearableUserEventGestureTypeDoubleTap = 0,
  WearableUserEventGestureTypeTripleTap = 1,
  WearableUserEventGestureTypeUnknown = 2,
};

#pragma clang diagnostic pop
